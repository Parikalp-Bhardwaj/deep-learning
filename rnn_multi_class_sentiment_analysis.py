# -*- coding: utf-8 -*-
"""RNN_Multi-class Sentiment Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oS1imi_3Cx0CxluqI7iZcu3KzDHgZtRB
"""

!pip install contractions
!pip install unidecode

import pandas as pd
import numpy as np
import os
import torch
import torch.nn as nn
import torchtext
import random
import time
import torch.nn.functional as F
import re
import spacy
from unidecode import unidecode
import contractions
from torchtext.legacy.data import TabularDataset,BucketIterator,get_tokenizer,Field,LabelField

dirs="/content/drive/MyDrive/dataset/Bcc_news_classification/bbc-fulltext (document classification)/bbc"

Dir="/content/drive/MyDrive/dataset/Bcc_news_classification/bbc-fulltext (document classification)/bbc"

texts=[]
labels=[]
for folder in os.listdir(Dir):
  if "TXT" in folder:
    continue
  paths=os.path.join(Dir,folder)
  for path in os.listdir(paths):
    # print(paths+"/"+path)
    with open(paths+"/"+path,"r", encoding = "latin") as file:
      data=file.read()
      data = data.replace("\n"," ").replace('\r','')
      texts.append(data)
      file.close() # file is being closed
#     letting the category of the news as the folder name in which it reside
      labels.append(folder)

df=pd.DataFrame({"text":texts,"label":labels})

df.head()

df["label"].value_counts()



df["text"]=df["text"].apply(lambda x:x.lower())

df.isnull().sum()

def expend_contraction(txt):
  list_contraction=[]
  for word in txt.split():
    list_contraction.append(contractions.fix(word))

  expend_word=" ".join(list_contraction)
  return expend_word

df["text"]=df["text"].apply(lambda x:expend_contraction(x))

df["text"]=df["text"].apply(lambda x:unidecode(x))

df["text"]=df["text"].apply(lambda x:re.sub(r'http\S+', '', x))

df["text"]=df["text"].apply(lambda x:re.sub('[^A-Za-z0-9]+', ' ', x))

df.head()

df.to_csv("/content/drive/MyDrive/dataset/Bcc_news_classification/bbc-fulltext (document classification)/All_data.csv",index=False)









TEXT=Field(tokenize="spacy",tokenizer_language='en_core_web_sm')
LABEL=LabelField()

field=[("text",TEXT),("label",LABEL)]

training_data=TabularDataset(path="/content/drive/MyDrive/dataset/Bcc_news_classification/bbc-fulltext (document classification)/All_data.csv",
                             format="csv",fields=field,skip_header=True)

print(vars(training_data[3]))

len(training_data)

train_data,valid_data=training_data.split(random_state=random.SEED(2020))

len(train_data),len(valid_data)



TEXT.build_vocab(train_data,max_size=25_000,vectors="glove.6B.100d",unk_init=torch.Tensor.normal_)
LABEL.build_vocab(train_data)



LABEL.vocab.stoi

device=torch.device("cuda" if torch.cuda.is_available() else "cpu")
train_iterator,valid_iterator=BucketIterator.splits((train_data,valid_data),
                                                    sort_key=lambda x:len(x.text),
                                                    batch_size=64,
                                                    device=device)



class CNN(nn.Module):
  def __init__(self,vocab_size,embedding_dim,output_dim,n_filers,filter_size,dropout,pad_token):
    super().__init__()
    self.embedding=nn.Embedding(vocab_size,embedding_dim,padding_idx=pad_token)
    self.convs=nn.ModuleList([nn.Conv2d(in_channels=1,out_channels=n_filers,kernel_size=(fs,embedding_dim))
                              for fs in filter_size])
    
    self.fc=nn.Linear(len(filter_size)*n_filter,output_dim)
    self.dropout=nn.Dropout(dropout)

  def forward(self,text):
    embedded=self.embedding(text)
    embedded=embedded.permute(1,0,2)
    embedded=embedded.unsqueeze(1)

    #Applying convs layers
    conved=[F.relu(conv(embedded)).squeeze(3) for conv in self.convs]
    #Applying pooling layer
    pooled=[F.max_pool1d(conv,conv.shape[2]).squeeze(2) for conv in conved]
    #pooled_n=[batch_size,n_filters]
    cat=self.dropout(torch.cat(pooled,dim=1))
    #cat = [batch_size,n_filers*len(filter_size)]
    return self.fc(cat)

vocab_size=len(TEXT.vocab)
embedding_dim=100
output_dim=len(LABEL.vocab)
n_filter=100
filter_size=[2,3,4]
dropout=0.5
PAD_IDX = TEXT.vocab.stoi[TEXT.pad_token]
model=CNN(vocab_size,embedding_dim,output_dim,n_filter,filter_size,dropout,PAD_IDX)

model

for i in train_iterator:
  txt=i.text
  print(model(txt))
  break

def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)

print(f'The model has {count_parameters(model):,} trainable parameters')

pretrained_embeddings = TEXT.vocab.vectors

model.embedding.weight.data.copy_(pretrained_embeddings)

UNK_IDX = TEXT.vocab.stoi[TEXT.unk_token]

model.embedding.weight.data[UNK_IDX] = torch.zeros(embedding_dim)
model.embedding.weight.data[PAD_IDX] = torch.zeros(embedding_dim)

import torch.optim as optim

optimizer = optim.Adam(model.parameters())

criterion = nn.CrossEntropyLoss()

model = model.to(device)
criterion = criterion.to(device)

def categorical_accuracy(preds, y):
    """
    Returns accuracy per batch, i.e. if you get 8/10 right, this returns 0.8, NOT 8
    """
    top_pred = preds.argmax(1, keepdim = True)
    correct = top_pred.eq(y.view_as(top_pred)).sum()
    acc = correct.float() / y.shape[0]
    return acc

def train(model, iterator, optimizer, criterion):
    
    epoch_loss = 0
    epoch_acc = 0
    
    model.train()
    
    for batch in iterator:
        
        optimizer.zero_grad()
        
        predictions = model(batch.text)
        
        loss = criterion(predictions, batch.label)
        
        acc = categorical_accuracy(predictions, batch.label)
        
        loss.backward()
        
        optimizer.step()
        
        epoch_loss += loss.item()
        epoch_acc += acc.item()
        
    return epoch_loss / len(iterator), epoch_acc / len(iterator)

def evaluate(model, iterator, criterion):
    
    epoch_loss = 0
    epoch_acc = 0
    
    model.eval()
    
    with torch.no_grad():
    
        for batch in iterator:

            predictions = model(batch.text)
            
            loss = criterion(predictions, batch.label)
            
            acc = categorical_accuracy(predictions, batch.label)

            epoch_loss += loss.item()
            epoch_acc += acc.item()
        
    return epoch_loss / len(iterator), epoch_acc / len(iterator)

N_EPOCHS = 5

best_valid_loss = float('inf')

for epoch in range(N_EPOCHS):

    # start_time = time.time()
    
    train_loss, train_acc = train(model, train_iterator, optimizer, criterion)
    valid_loss, valid_acc = evaluate(model, valid_iterator, criterion)
    
    # end_time = time.time()

    # epoch_mins, epoch_secs = epoch_time(start_time, end_time)
    
    if valid_loss < best_valid_loss:
        best_valid_loss = valid_loss
        torch.save(model.state_dict(), dirs+'Multi-class_Sentiment_Analysis.pt')
    
    # print(f'Epoch: {epoch+1:02} | Epoch Time: {epoch_mins}m {epoch_secs}s')
    print(f'\tTrain Loss: {train_loss:.3f} | Train Acc: {train_acc*100:.2f}%')
    print(f'\t Val. Loss: {valid_loss:.3f} |  Val. Acc: {valid_acc*100:.2f}%')





import spacy
nlp = spacy.load('en_core_web_sm')

def predict_class(model, sentence, min_len = 4):
    model.eval()
    tokenized = [tok.text for tok in nlp.tokenizer(sentence)]
    if len(tokenized) < min_len:
        tokenized += ['<pad>'] * (min_len - len(tokenized))
    indexed = [TEXT.vocab.stoi[t] for t in tokenized]
    tensor = torch.LongTensor(indexed).to(device)
    tensor = tensor.unsqueeze(1)
    preds = model(tensor)
    max_preds = preds.argmax(dim = 1)
    return max_preds.item()

pred_class = predict_class(model, "i love this film")
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')

pred_class = predict_class(model, "i love playing cricket")
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')

pred_class = predict_class(model, "google search")
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')

pred_class = predict_class(model, "Sports is the ultimate destination for Sports fans from around the World")
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')

pred_class = predict_class(model, "market today, stock, economy news from India")
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')



red_class = predict_class(model, " stay connected with BloombergQuint. Be up to date with today's business news headlines, finance bulletin")
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')

pred_class = predict_class(model, "The protests were held in Dum Dum, Central Avenue and Chetla areas of Kolkata, Canning in South 24 Parganas, Chinsurah in Hooghly, and Malda, besides")
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')



pred_class = predict_class(model, ("The Family Man 2's Dhriti actor Ashlesha Thakur gets 'rishtas' in her DMs".lower()))
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')



pred_class = predict_class(model, ("PUBG Mobile World Invitational 2021 announced, thereâ€™s $3 million charity prize pool involved").lower())
print(f'Predicted class is: {pred_class} = {LABEL.vocab.itos[pred_class]}')



LABEL.vocab.stoi

